#include <GL/glut.h>
#include <vector>
#include <cmath>
#include <algorithm>

#define M_PI 3.14159265f

float Ka = 0.2f;
float Kd = 0.7f;
float Ks = 0.2f;
float n = 8.0f;
float Ia = 0.3f;
float Il = 5.0f;
float k = 1.0f;


struct Point {
    float x, y, z;
    Point(float x = 0, float y = 0, float z = 0) : x(x), y(y), z(z) {}

    Point operator+(const Point& o) const { return Point(x + o.x, y + o.y, z + o.z); }
    Point operator-(const Point& o) const { return Point(x - o.x, y - o.y, z - o.z); }
    Point operator*(float s) const { return Point(x * s, y * s, z * s); }
};

Point lightPos(0, 5, 5);
Point viewPos(0, 2, 6);

struct Triangle {
    int v1, v2, v3; 
    Triangle(int v1, int v2, int v3) : v1(v1), v2(v2), v3(v3) {} 
};

std::vector<Point> vertices, vertexNormals;
std::vector<float> vertexIntensities;
std::vector<Triangle> triangles;

float distance(const Point& a, const Point& b) {
    float dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;
    return sqrt(dx * dx + dy * dy + dz * dz);
}

Point normalize(const Point& v) {
    float len = sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    return (len > 0) ? Point(v.x / len, v.y / len, v.z / len) : v;
}

float scalar(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }

Point cross(const Point& a, const Point& b) {
    return Point(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}

int profileSegments = 18;
int rotationSegments = 72;
float radius = 1.0f;
std::vector<Point> profile;

void createFigure() {
    profile.clear();
    for (int i = 0; i <= profileSegments; i++) {
        float t = M_PI * i / profileSegments;
        profile.push_back(Point(radius * sin(t), radius * cos(t), 0));
    }
}

std::vector<Point> rotateProfile(const std::vector<Point>& prof, float a) {
    std::vector<Point> r;
    float ca = cos(a), sa = sin(a);
    for (const auto& p : prof) {
        float x = p.x * ca - p.z * sa;
        float z = p.x * sa + p.z * ca;
        r.push_back(Point(x, p.y, z));
    }
    return r;
}

Point triNormal(const Point& a, const Point& b, const Point& c) {
    return normalize(cross(b - a, c - a));
}

float calcIntensity(const Point& normal, const Point& point) {
    Point L = normalize(lightPos - point);
    Point S = normalize(viewPos - point);

    float NL = std::max(0.0f, scalar(normal, L));

    Point R = normalize(normal * (2.0f * NL) - L);
    float RS = std::max(0.0f, scalar(R, S));

    float d = distance(point, lightPos);
    return Ia * Ka + (Il / (k + d)) * (Kd * NL + Ks * pow(RS, n));
}

void buildMesh() {
    vertices.clear();
    triangles.clear();

    std::vector<int> prev;

    for (int r = 0; r <= rotationSegments; r++) {
        float ang = 2 * M_PI * r / rotationSegments;
        auto ring = rotateProfile(profile, ang);
        std::vector<int> curr;

        for (const auto& p : ring) {
            vertices.push_back(p);
            curr.push_back(vertices.size() - 1);
        }

        if (!prev.empty()) {
            for (int i = 0; i < profileSegments; i++) {
                int a = prev[i], b = prev[i + 1], c = curr[i + 1], d = curr[i];
                triangles.emplace_back(a, b, c);
                triangles.emplace_back(a, c, d);
            }
        }
        prev = curr;
    }

    vertexNormals.resize(vertices.size());
    for (size_t i = 0; i < vertices.size(); i++)
        vertexNormals[i] = normalize(vertices[i]);

    vertexIntensities.resize(vertices.size());
    for (size_t i = 0; i < vertices.size(); i++)
        vertexIntensities[i] = calcIntensity(vertexNormals[i], vertices[i]);
}

float yaw = -90.0f;
float pitch = 0.0f;
Point front(0, 0, -1);
Point worldUp(0, 1, 0);
float speed = 0.2f;

Point right, up;

void updateCameraVectors() {
    front.x = cosf(yaw * M_PI / 180.0f) * cosf(pitch * M_PI / 180.0f);
    front.y = sinf(pitch * M_PI / 180.0f);
    front.z = sinf(yaw * M_PI / 180.0f) * cosf(pitch * M_PI / 180.0f);
    front = normalize(front);

    Point horizontalFront = front;
    horizontalFront.y = 0;
    right = normalize(cross(horizontalFront, worldUp));

    up = normalize(cross(right, front));
}


void keyboard(unsigned char key, int x, int y) {
    if (key == 'w') viewPos = viewPos + front * speed;
    if (key == 's') viewPos = viewPos - front * speed;
    if (key == 'a') viewPos = viewPos - right * speed;
    if (key == 'd') viewPos = viewPos + right * speed;

    glutPostRedisplay();
}

int lastMouseX = 400, lastMouseY = 300;
bool firstMouse = true;

void mouseMotion(int x, int y) {
    int centerX = 400, centerY = 300;
    static bool firstMouse = true;

    if (firstMouse) {
        lastMouseX = x;
        lastMouseY = y;
        firstMouse = false;
    }

    float xoffset = x - lastMouseX;
    float yoffset = lastMouseY - y;
    lastMouseX = x;
    lastMouseY = y;

    float sensitivity = 0.1f;
    xoffset *= sensitivity;
    yoffset *= sensitivity;

    yaw += xoffset;
    pitch += yoffset;

    if (pitch > 89.0f) pitch = 89.0f;
    if (pitch < -89.0f) pitch = -89.0f;

    updateCameraVectors();

    glutWarpPointer(centerX, centerY);
    lastMouseX = centerX;
    lastMouseY = centerY;

    glutPostRedisplay();
}


void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    Point center = viewPos + front;
    gluLookAt(viewPos.x, viewPos.y, viewPos.z, center.x, center.y, center.z, up.x, up.y, up.z);

    glBegin(GL_TRIANGLES);
    for (auto& t : triangles) {
        glColor3f(vertexIntensities[t.v1], vertexIntensities[t.v1], vertexIntensities[t.v1]);
        glVertex3f(vertices[t.v1].x, vertices[t.v1].y, vertices[t.v1].z);

        glColor3f(vertexIntensities[t.v2], vertexIntensities[t.v2], vertexIntensities[t.v2]);
        glVertex3f(vertices[t.v2].x, vertices[t.v2].y, vertices[t.v2].z);

        glColor3f(vertexIntensities[t.v3], vertexIntensities[t.v3], vertexIntensities[t.v3]);
        glVertex3f(vertices[t.v3].x, vertices[t.v3].y, vertices[t.v3].z);
    }
    glEnd();

    glutSwapBuffers();
}

void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, float(w) / h, 0.1, 100);
    glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(800, 600);
    glutCreateWindow("3D Viewer Clean");

    glEnable(GL_DEPTH_TEST);
    glClearColor(0, 0, 0, 1);

    createFigure();
    buildMesh();


    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutPassiveMotionFunc(mouseMotion);

    glutSetCursor(GLUT_CURSOR_NONE);


    glutMainLoop();
    return 0;
}
